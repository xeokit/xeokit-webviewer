/**
 * <img style="padding:20px" src="/docs/assets/geometry_icon.png"/>
 *
 * # xeokit Geometry Compression / Decompression Utilities
 *
 * This module provides geometry compression and decompression utilities used internally within
 * {@link scene!SceneModel.createGeometry | SceneModel.createGeometry}. These functions are exposed publicly,
 * allowing users to pre-compress geometry data before passing it to
 * {@link scene!SceneModel.createGeometryCompressed | SceneModel.createGeometryCompressed} for optimized rendering and storage.
 *
 * ## Compression Techniques
 *
 * The utilities in this module utilize the following compression techniques to reduce the size of 3D geometry data:
 *
 * * Merges duplicate vertex positions and updates indices to minimize data redundancy
 * * Generates edge indices for triangle meshes to facilitate faster rendering
 * * Omits normals (which are auto-generated by shaders during rendering)
 * * Converts positions to relative-to-center (RTC) coordinates for improved compression efficiency
 * * Quantizes positions and UVs as 16-bit unsigned integers for compact storage
 * * Compresses bounding box data and provides necessary matrices for efficient decompression
 *
 * ## Installation
 *
 * ```bash
 * npm install @xeokit/sdk
 * ```
 *
 * ## Usage
 *
 * The following examples demonstrate how to use the compression functions in this module:
 *
 * ### 1. Compressing Positions with AABB3 (Axis-Aligned Bounding Box)
 *
 * To compress a set of vertex positions, use the `compressPositions3` function, which quantizes the positions based on an AABB3:
 *
 * ```javascript
 * import {compressPositions3} from "@xeokit/sdk/compression";
 *
 * const positions = [0, 0, 0, 1, 1, 1, 2, 2, 2];
 * const aabb = [0, 0, 0, 2, 2, 2]; // The bounding box of the geometry
 *
 * const { quantized, decompressMatrix } = compressPositions3(positions, aabb);
 *
 * console.log(quantized); // The compressed (quantized) positions
 * console.log(decompressMatrix); // The matrix used for decompression
 * ```
 *
 * ### 2. Decompressing 3D Positions with a 4x4 Matrix
 *
 * To decompress a set of quantized positions using a transformation matrix, use the `decompressPositions3WithMat4` function:
 *
 * ```javascript
 * import {decompressPositions3WithMat4} from "@xeokit/sdk/compression";
 *
 * const quantizedPositions = [32767, 32767, 32767]; // Quantized data
 * const decompressMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; // Example identity matrix
 *
 * const decompressedPositions = decompressPositions3WithMat4(quantizedPositions, decompressMatrix);
 *
 * console.log(decompressedPositions); // The decompressed positions
 * ```
 *
 * ### 3. Compressing UV Coordinates
 *
 * The `compressUVs` function compresses UV coordinates using a similar approach to position compression:
 *
 * ```javascript
 * import {compressUVs} from "@xeokit/sdk/compression";
 *
 * const uvs = [0.0, 0.0, 0.5, 0.5, 1.0, 1.0];
 * const minUV = [0.0, 0.0];
 * const maxUV = [1.0, 1.0];
 *
 * const { quantized, decompressMatrix } = compressUVs(uvs, minUV, maxUV);
 *
 * console.log(quantized); // The compressed (quantized) UVs
 * console.log(decompressMatrix); // The matrix for UV decompression
 * ```
 *
 * ### 4. Decompressing 3D Position with AABB3
 *
 * To decompress a point from quantized data back into real-world coordinates, you can use `decompressPoint3WithAABB3`:
 *
 * ```javascript
 * import {decompressPoint3WithAABB3} from "@xeokit/sdk/compression";
 *
 * const compressedPoint = [32767, 32767, 32767]; // Example quantized point
 * const aabb = [0, 0, 0, 1, 1, 1]; // The AABB3 used during compression
 *
 * const decompressedPoint = decompressPoint3WithAABB3(compressedPoint, aabb);
 *
 * console.log(decompressedPoint); // The real-world coordinates of the point
 * ```
 *
 * @module compression
 */



import {
    createMat3,
    createMat4,
    createVec3,
    identityMat3,
    identityMat4,
    mulMat3,
    mulMat4,
    normalizeVec3,
    scalingMat3v,
    scalingMat4v,
    transformVec3,
    translationMat3v,
    translationMat4v
} from "../matrix";

import type {FloatArrayParam} from "../math";

const translate = createMat4();
const scale = createMat4();

/**
 * Retrieves the minimum and maximum values for a set of 3D positions.
 *
 * This function calculates the minimum and maximum values along each axis (x, y, and z) from an array of 3D positions.
 * The array is assumed to be a flat array where every three consecutive values represent a 3D position (x, y, z).
 *
 * @param {FloatArrayParam} array - The array of 3D positions to evaluate. The array length must be a multiple of 3.
 * @param {FloatArrayParam} [min] - Optional pre-allocated array to store the minimum values. Defaults to a new array if not provided.
 * @param {FloatArrayParam} [max] - Optional pre-allocated array to store the maximum values. Defaults to a new array if not provided.
 * @returns {Object} - An object containing the min and max values as arrays:
 *  - `min`: The minimum values along the x, y, and z axes.
 *  - `max`: The maximum values along the x, y, and z axes.
 *
 * @example
 * const positions = new Float32Array([1, 2, 3, 4, 5, 6, -1, -2, -3]);
 * const { min, max } = getPositions3MinMax(positions);
 * console.log(min); // [-1, -2, -3]
 * console.log(max); // [4, 5, 6]
 */
export function getPositions3MinMax(
    array: FloatArrayParam,
    min: FloatArrayParam = new Float64Array(3),
    max: FloatArrayParam = new Float64Array(3)
) {
    // Initialize min and max values with extreme values
    for (let i = 0; i < 3; i++) {
        min[i] = Number.MAX_VALUE;
        max[i] = -Number.MAX_VALUE;
    }

    // Iterate through each 3D position in the array
    for (let i = 0; i < array.length; i += 3) {
        // Update min and max for each axis (x, y, z)
        for (let j = 0; j < 3; j++) {
            min[j] = Math.min(min[j], array[i + j]);
            max[j] = Math.max(max[j], array[i + j]);
        }
    }

    return {
        min,
        max
    };
}


/**
 * Creates a 4x4 matrix for decompressing 3D positions based on a given axis-aligned bounding box (AABB).
 * This matrix is used to map compressed positions back to their original space.
 *
 * @param {FloatArrayParam} aabb - The axis-aligned bounding box (AABB) defined by [xmin, ymin, zmin, xmax, ymax, zmax].
 * @param {FloatArrayParam} [positionsDecompressMatrix] - An optional pre-allocated matrix to store the result. Defaults to a new matrix if not provided.
 * @returns {FloatArrayParam} - The decompression matrix used for transforming compressed positions back to their original scale.
 *
 * @example
 * const aabb = [0, 0, 0, 10, 10, 10];
 * const decompressionMatrix = createPositions3DecompressMat4(aabb);
 */
export function createPositions3DecompressMat4(
    aabb: FloatArrayParam,
    positionsDecompressMatrix: FloatArrayParam = createMat4()
): FloatArrayParam {
    // Extract AABB min and max values
    const [xmin, ymin, zmin, xmax, ymax, zmax] = aabb;

    // Calculate the width of the AABB along each axis
    const xwid = xmax - xmin;
    const ywid = ymax - ymin;
    const zwid = zmax - zmin;

    // The maximum integer value for decompression
    const maxInt = 65535;

    // Initialize translation and scaling matrices
    identityMat4(translate); // Reset the translation matrix
    translationMat4v(aabb, translate); // Apply the translation from the AABB

    identityMat4(scale); // Reset the scale matrix
    scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale); // Apply scaling based on AABB width and maxInt

    // Multiply the translation and scale matrices to get the final decompression matrix
    mulMat4(translate, scale, positionsDecompressMatrix);

    return positionsDecompressMatrix; // Return the decompression matrix
}


/**
 * Compresses a flat array of 3D positions into a quantized format, and computes the matrix for decompressing
 * back to the original range.
 *
 * @param {FloatArrayParam} array - The array of 3D positions to be compressed.
 * @param {FloatArrayParam} min - The minimum bounds for the 3D positions.
 * @param {FloatArrayParam} max - The maximum bounds for the 3D positions.
 * @returns {Object} - An object containing the quantized positions and the decompression matrix.
 *
 * @example
 * const positions = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6];
 * const min = [0, 0, 0];
 * const max = [1, 1, 1];
 * const { quantized, decompressMatrix } = compressPositions3(positions, min, max);
 */
export function compressPositions3(array: FloatArrayParam, min: FloatArrayParam, max: FloatArrayParam) {
    // Initialize a quantized array to store the compressed positions
    const quantized = new Uint16Array(array.length);

    // Calculate the scaling multipliers based on the difference between min and max values
    const multiplier = new Float32Array([
        max[0] !== min[0] ? 65535 / (max[0] - min[0]) : 0,
        max[1] !== min[1] ? 65535 / (max[1] - min[1]) : 0,
        max[2] !== min[2] ? 65535 / (max[2] - min[2]) : 0
    ]);

    // Compress the positions by quantizing each component
    for (let i = 0; i < array.length; i += 3) {
        quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
        quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);
    }

    // Create the decompression matrix for transforming compressed positions back to their original space
    const translate = createMat4();
    translationMat4v(min, translate); // Apply translation based on the minimum bounds

    const scale = createMat4();
    scalingMat4v([
        (max[0] - min[0]) / 65535,
        (max[1] - min[1]) / 65535,
        (max[2] - min[2]) / 65535
    ], scale); // Apply scaling based on the difference between max and min

    const decompressMatrix = mulMat4(translate, scale, identityMat4()); // Combine translation and scaling into the decompression matrix

    // Return the quantized positions and the decompression matrix
    return {
        quantized,
        decompressMatrix
    };
}


/**
 * Compresses a single 3D point (p) within a specified axis-aligned bounding box (AABB) and stores the result in dest.
 * The point is quantized to fit within the range [0, 65535] based on the AABB bounds.
 *
 * @param {FloatArrayParam} p - The 3D point to be compressed.
 * @param {FloatArrayParam} aabb - The axis-aligned bounding box [xmin, ymin, zmin, xmax, ymax, zmax].
 * @param {FloatArrayParam} dest - The destination array where the compressed point will be stored. Defaults to the input point (p).
 * @returns {FloatArrayParam} - The compressed point in dest.
 *
 * @example
 * const point = [0.5, 0.5, 0.5];
 * const aabb = [0, 0, 0, 1, 1, 1];
 * const compressedPoint = compressPoint3WithAABB3(point, aabb);
 */
export function compressPoint3WithAABB3(p: FloatArrayParam, aabb: FloatArrayParam, dest: FloatArrayParam = p): FloatArrayParam {
    // Compute the scale factors based on the AABB dimensions
    const multiplier = new Float32Array([
        aabb[3] !== aabb[0] ? 65535 / (aabb[3] - aabb[0]) : 0,
        aabb[4] !== aabb[1] ? 65535 / (aabb[4] - aabb[1]) : 0,
        aabb[5] !== aabb[2] ? 65535 / (aabb[5] - aabb[2]) : 0
    ]);

    // Quantize each component of the point and clamp to the range [0, 65535]
    dest[0] = Math.max(0, Math.min(65535, Math.floor((p[0] - aabb[0]) * multiplier[0])));
    dest[1] = Math.max(0, Math.min(65535, Math.floor((p[1] - aabb[1]) * multiplier[1])));
    dest[2] = Math.max(0, Math.min(65535, Math.floor((p[2] - aabb[2]) * multiplier[2])));

    return dest;
}

/**
 * Decompresses a 3D point (position) using a given 4x4 matrix (decompressMatrix).
 * This function applies the matrix transformations to the position to restore the original values.
 *
 * @param {FloatArrayParam} position - The compressed 3D point to be decompressed.
 * @param {FloatArrayParam} decompressMatrix - A 4x4 matrix used to decompress the position.
 * @param {FloatArrayParam} dest - The destination array to store the decompressed point. Defaults to the input position.
 * @returns {FloatArrayParam} - The decompressed 3D point stored in dest.
 *
 * @example
 * const compressedPosition = [100, 150, 200];
 * const matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
 * const decompressedPoint = decompressPoint3WithMat4(compressedPosition, matrix);
 */
export function decompressPoint3WithMat4(
    position: FloatArrayParam,
    decompressMatrix: FloatArrayParam,
    dest: FloatArrayParam = position
): FloatArrayParam {
    // Apply matrix transformation to each component of the position
    dest[0] = position[0] * decompressMatrix[0] + decompressMatrix[12];
    dest[1] = position[1] * decompressMatrix[5] + decompressMatrix[13];
    dest[2] = position[2] * decompressMatrix[10] + decompressMatrix[14];

    return dest;
}


/**
 * Decompresses a 3D point (position) based on a given AABB (Axis-Aligned Bounding Box).
 * The function scales and offsets the position to restore it to its original coordinates.
 *
 * @param {FloatArrayParam} position - The compressed 3D point to be decompressed.
 * @param {FloatArrayParam} aabb - The AABB (min and max values) used to decompress the position.
 * @param {FloatArrayParam} dest - The destination array to store the decompressed point. Defaults to the input position.
 * @returns {FloatArrayParam} - The decompressed 3D point stored in dest.
 *
 * @example
 * const compressedPosition = [30000, 30000, 30000];
 * const aabb = [0, 0, 0, 10000, 10000, 10000];
 * const decompressedPoint = decompressPoint3WithAABB3(compressedPosition, aabb);
 */
export function decompressPoint3WithAABB3(
    position: FloatArrayParam,
    aabb: FloatArrayParam,
    dest: FloatArrayParam = position
): FloatArrayParam {
    // Calculate scaling and offsets based on the AABB values
    const xScale = (aabb[3] - aabb[0]) / 65535;
    const xOffset = aabb[0];
    const yScale = (aabb[4] - aabb[1]) / 65535;
    const yOffset = aabb[1];
    const zScale = (aabb[5] - aabb[2]) / 65535;
    const zOffset = aabb[2];

    // Decompress the position values using the scale and offset
    dest[0] = position[0] * xScale + xOffset;
    dest[1] = position[1] * yScale + yOffset;
    dest[2] = position[2] * zScale + zOffset;

    return dest;
}


/**
 * Decompresses an AABB (Axis-Aligned Bounding Box) using a transformation matrix.
 * This function applies a matrix to each corner of the AABB to compute the decompressed AABB.
 *
 * @param {FloatArrayParam} aabb - The AABB values to be decompressed (min and max values).
 * @param {FloatArrayParam} decompressMatrix - The transformation matrix used to decompress the AABB.
 * @param {FloatArrayParam} dest - The destination array where the decompressed AABB will be stored. Defaults to the input AABB.
 * @returns {FloatArrayParam} - The decompressed AABB stored in `dest`.
 *
 * @example
 * const aabb = [0, 0, 0, 10, 10, 10]; // Example AABB
 * const matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; // Example identity matrix
 * const decompressedAABB = decompressAABB3WithMat4(aabb, matrix);
 */
export function decompressAABB3WithMat4(
    aabb: FloatArrayParam,
    decompressMatrix: FloatArrayParam,
    dest: FloatArrayParam = aabb
): FloatArrayParam {
    // Decompress each corner of the AABB using the matrix
    dest[0] = aabb[0] * decompressMatrix[0] + decompressMatrix[12]; // minX
    dest[1] = aabb[1] * decompressMatrix[5] + decompressMatrix[13]; // minY
    dest[2] = aabb[2] * decompressMatrix[10] + decompressMatrix[14]; // minZ
    dest[3] = aabb[3] * decompressMatrix[0] + decompressMatrix[12]; // maxX
    dest[4] = aabb[4] * decompressMatrix[5] + decompressMatrix[13]; // maxY
    dest[5] = aabb[5] * decompressMatrix[10] + decompressMatrix[14]; // maxZ

    return dest;
}


/**
 * Decompresses an AABB (Axis-Aligned Bounding Box) using another AABB as reference for scaling and offset.
 * This function applies the scaling and offset defined by the second AABB to the first AABB.
 *
 * @param {FloatArrayParam} aabb - The AABB values to be decompressed (min and max values).
 * @param {FloatArrayParam} aabb2 - The reference AABB used for decompression (min and max values).
 * @param {FloatArrayParam} dest - The destination array where the decompressed AABB will be stored. Defaults to the input AABB.
 * @returns {FloatArrayParam} - The decompressed AABB stored in `dest`.
 *
 * @example
 * const aabb = [0, 0, 0, 10, 10, 10]; // Example AABB
 * const aabb2 = [0, 0, 0, 20, 20, 20]; // Example reference AABB for scaling
 * const decompressedAABB = decompressAABB3WithAABB3(aabb, aabb2);
 */
export function decompressAABB3WithAABB3(
    aabb: FloatArrayParam,
    aabb2: FloatArrayParam,
    dest: FloatArrayParam = aabb
): FloatArrayParam {
    // Calculate scaling and offsets based on aabb2
    const xScale = (aabb2[3] - aabb2[0]) / 65535;
    const xOffset = aabb2[0];
    const yScale = (aabb2[4] - aabb2[1]) / 65535;
    const yOffset = aabb2[1];
    const zScale = (aabb2[5] - aabb2[2]) / 65535;
    const zOffset = aabb2[2];

    // Decompress each corner of the AABB using the calculated scale and offset
    dest[0] = aabb[0] * xScale + xOffset; // minX
    dest[1] = aabb[1] * yScale + yOffset; // minY
    dest[2] = aabb[2] * zScale + zOffset; // minZ
    dest[3] = aabb[3] * xScale + xOffset; // maxX
    dest[4] = aabb[4] * yScale + yOffset; // maxY
    dest[5] = aabb[5] * zScale + zOffset; // maxZ

    return dest;
}


/**
 * Decompresses a flat array of quantized 3D positions using a 4x4 matrix for scaling and offsetting.
 *
 * This function applies the provided decompression matrix to the quantized positions. Each position is transformed by the matrix
 * to restore the original 3D coordinates. The decompression matrix should represent scaling and translation transformations.
 *
 * @param {FloatArrayParam} positions - The quantized positions array to be decompressed. Each position is a 3D point (x, y, z).
 * @param {FloatArrayParam} decompressMatrix - The 4x4 matrix used to decompress the positions. It contains scaling and translation values.
 * @param {Float32Array} [dest=new Float32Array(positions.length)] - The destination array to store the decompressed positions.
 * @returns {Float32Array} - The decompressed positions array.
 *
 * @example
 * const quantizedPositions = new Uint16Array([1000, 2000, 3000, 4000, 5000, 6000]);
 * const decompressMatrix = new Float32Array([
 *     1, 0, 0, 0,
 *     0, 1, 0, 0,
 *     0, 0, 1, 0,
 *     0, 0, 0, 1
 * ]);
 * const decompressed = decompressPositions3WithMat4(quantizedPositions, decompressMatrix);
 * console.log(decompressed); // [scaledX, scaledY, scaledZ, ...]
 */
export function decompressPositions3WithMat4(
    positions: FloatArrayParam,
    decompressMatrix: FloatArrayParam,
    dest: Float32Array<any> = new Float32Array(positions.length)
): Float32Array<any> {
    const m = decompressMatrix;

    // Decompress each position using the decompression matrix
    for (let i = 0, len = positions.length; i < len; i += 3) {
        dest[i]     = positions[i] * m[0] + m[12];  // Apply scale and translation to x-coordinate
        dest[i + 1] = positions[i + 1] * m[5] + m[13];  // Apply scale and translation to y-coordinate
        dest[i + 2] = positions[i + 2] * m[10] + m[14]; // Apply scale and translation to z-coordinate
    }

    return dest;
}


/**
 * Decompresses a flat array of quantized 3D positions using an axis-aligned bounding box (AABB) to scale and offset.
 *
 * This function restores the original 3D positions by scaling and offsetting the quantized values using the provided AABB.
 * It calculates the scale and offset for each axis based on the AABB and the maximum quantization value (65535).
 *
 * @param {FloatArrayParam} positions - The quantized positions array to be decompressed. Each position is a 3D point (x, y, z).
 * @param {FloatArrayParam} aabb - The AABB used for decompressing. The AABB contains 6 values: [xmin, ymin, zmin, xmax, ymax, zmax].
 * @param {FloatArrayParam} [dest=new Float32Array(positions.length)] - The destination array to store the decompressed positions.
 * @returns {FloatArrayParam} - The decompressed positions array.
 *
 * @example
 * const quantizedPositions = new Uint16Array([1000, 2000, 3000, 4000, 5000, 6000]);
 * const aabb = new Float32Array([0, 0, 0, 10000, 10000, 10000]);
 * const decompressed = decompressPositions3WithAABB3(quantizedPositions, aabb);
 * console.log(decompressed); // [0.015, 0.03, 0.045, 0.06, 0.075, 0.09]
 */
export function decompressPositions3WithAABB3(
    positions: FloatArrayParam,
    aabb: FloatArrayParam,
    dest: FloatArrayParam = new Float32Array(positions.length)
): FloatArrayParam {
    // Calculate the scale and offset for each axis
    const xScale = (aabb[3] - aabb[0]) / 65535;
    const xOffset = aabb[0];
    const yScale = (aabb[4] - aabb[1]) / 65535;
    const yOffset = aabb[1];
    const zScale = (aabb[5] - aabb[2]) / 65535;
    const zOffset = aabb[2];

    // Decompress positions by applying the scale and offset for each axis
    for (let i = 0; i < positions.length; i += 3) {
        dest[i]     = positions[i] * xScale + xOffset;  // Decompress x-coordinate
        dest[i + 1] = positions[i + 1] * yScale + yOffset;  // Decompress y-coordinate
        dest[i + 2] = positions[i + 2] * zScale + zOffset;  // Decompress z-coordinate
    }

    return dest;
}



/**
 * Computes the minimum and maximum bounds for a flat array of UV coordinates.
 *
 * This function iterates over a flat array of UV coordinates and computes the
 * minimum and maximum values for each component (u, v). These bounds can be used
 * for various operations like normalization, quantization, or texture mapping.
 *
 * @param {FloatArrayParam} array - The input array of UV coordinates (each UV pair consisting of [u, v]).
 * @returns {Object} - An object containing:
 *   - `min`: The minimum values for each component ([u, v]).
 *   - `max`: The maximum values for each component ([u, v]).
 *
 * @example
 * const uvs = new Float32Array([0.1, 0.2, 0.5, 0.6, 0.3, 0.4]);
 * const { min, max } = getUVBounds(uvs);
 * console.log(min); // [0.1, 0.2]
 * console.log(max); // [0.5, 0.6]
 */
export function getUVBounds(array: FloatArrayParam): { min: FloatArrayParam, max: FloatArrayParam } {
    // Initialize min and max values to extreme bounds
    const min = new Float32Array(2).fill(Number.MAX_VALUE);
    const max = new Float32Array(2).fill(-Number.MAX_VALUE);

    // Iterate over the UV coordinates and update the min and max bounds
    for (let i = 0; i < array.length; i += 2) {
        min[0] = Math.min(min[0], array[i]);       // Update minimum u value
        min[1] = Math.min(min[1], array[i + 1]);   // Update minimum v value
        max[0] = Math.max(max[0], array[i]);       // Update maximum u value
        max[1] = Math.max(max[1], array[i + 1]);   // Update maximum v value
    }

    return {min, max};
}


/**
 * Compresses a flat array of UV coordinates into a quantized representation.
 *
 * This function maps the input UV coordinates to a 16-bit integer range [0, 65535]
 * based on the provided min and max bounds for each coordinate. The resulting quantized
 * UVs are returned along with a matrix that can be used to decompress them back to
 * their original range. This is commonly used in texture mapping for more efficient storage.
 *
 * The compression uses a simple linear transformation based on the provided min and max values
 * for each component of the UV coordinates.
 *
 * @param {FloatArrayParam} array - The input array of UV coordinates (each UV pair consisting of [u, v]).
 * @param {FloatArrayParam} min - The minimum values for [u, v] coordinates to scale to the quantized range.
 * @param {FloatArrayParam} max - The maximum values for [u, v] coordinates to scale to the quantized range.
 * @returns {Object} - An object containing:
 *   - `quantized`: The quantized UV coordinates as a Uint16Array.
 *   - `decompressMatrix`: A matrix (either FloatArray or Float64Array) used to decompress the quantized UVs back to their original values.
 *
 * @example
 * const uvs = new Float32Array([0.1, 0.2, 0.5, 0.6]);
 * const min = new Float32Array([0, 0]);
 * const max = new Float32Array([1, 1]);
 * const { quantized, decompressMatrix } = compressUVs(uvs, min, max);
 */
export function compressUVs(array: FloatArrayParam, min: FloatArrayParam, max: FloatArrayParam): {
    quantized: Uint16Array<any>,
    decompressMatrix: FloatArrayParam
} {
    const quantized = new Uint16Array(array.length);

    // Compute multipliers for each component (u, v) to map them to the [0, 65535] range
    const multipliers = new Float32Array([
        65535 / (max[0] - min[0]),
        65535 / (max[1] - min[1])
    ]);

    // Quantize the UV coordinates
    for (let i = 0; i < array.length; i += 2) {
        quantized[i] = Math.floor((array[i] - min[0]) * multipliers[0]);
        quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multipliers[1]);
    }

    // Create transformation matrices for decompressing
    identityMat3(translate);
    translationMat3v(min, translate);

    identityMat3(scale);
    scalingMat3v([
        (max[0] - min[0]) / 65535,
        (max[1] - min[1]) / 65535
    ], scale);

    const decompressMatrix = mulMat3(translate, scale, identityMat3());

    return {
        quantized,
        decompressMatrix
    };
}


/**
 * Oct-encodes a flat array of normal vectors
 * @param array
 */
/**
 * Compresses a flat array of 3D normal vectors using oct-encoding.
 *
 * This function compresses an array of 3D normal vectors into a smaller array of oct-encoded normals.
 * The compression minimizes storage requirements while preserving the direction of the normals.
 * The last element in each triplet is redundant due to a workaround for WebGL issues where
 * 2-element normals would not behave correctly in the shader.
 *
 * The function performs various oct-encoding operations using combinations of `ceil` and `floor` to
 * minimize rounding errors during compression.
 *
 * @param {FloatArrayParam} array - The input array of 3D normals (each consisting of three components: x, y, z).
 * @returns {Int8Array} The compressed array of oct-encoded normals, with redundant third components.
 *
 * @example
 * const normals = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
 * const compressed = compressNormals(normals);
 * console.log(compressed); // Compressed oct-encoded normals
 */
export function compressNormals(array: FloatArrayParam): Int8Array<any> {
    // Initialize the encoded result array (same length as input but compressed)
    const encoded = new Int8Array(array.length);

    let oct: Int8Array<any>, dec: FloatArrayParam, best: Int8Array<any>, currentCos: number, bestCos: number;

    // Iterate through each normal in the array (processed in triplets)
    for (let i = 0; i < array.length; i += 3) {
        // Initialize the best encoding using the first encoding strategy (floor, floor)
        best = oct = octEncodeNormalFromArray(array, i, "floor", "floor");
        dec = octDecodeVec2(oct);
        bestCos = currentCos = dot(array, i, dec);

        // Test ceil/floor, floor/ceil, and ceil/ceil strategies to minimize rounding errors
        const strategies: [string, string][] = [
            ["ceil", "floor"],
            ["floor", "ceil"],
            ["ceil", "ceil"]
        ];

        // Loop over the strategies and pick the one with the best cosine similarity
        strategies.forEach(([xFunc, yFunc]) => {
            oct = octEncodeNormalFromArray(array, i, xFunc, yFunc);
            dec = octDecodeVec2(oct);
            currentCos = dot(array, i, dec);
            if (currentCos > bestCos) {
                best = oct;
                bestCos = currentCos;
            }
        });

        // Store the best compressed values for the current normal
        encoded[i] = best[0];
        encoded[i + 1] = best[1];
    }

    return encoded;
}


/**
 * Oct-encodes a single normal vector into a 2-byte `Int8Array`.
 *
 * This function converts a 3D normal vector into a 2D octahedral representation.
 * The encoding compresses the normal while preserving as much detail as possible.
 *
 * @param {FloatArrayParam} array - The array containing the normal vector components.
 * @param {number} i - The index of the normal vector's X component in the array.
 * @param {Function} xfunc - A Math function (e.g., `Math.floor`, `Math.round`) to process the X component.
 * @param {Function} yfunc - A Math function (e.g., `Math.floor`, `Math.round`) to process the Y component.
 * @returns {Int8Array} A 2-element `Int8Array` containing the encoded normal.
 */
function octEncodeNormalFromArray(array: FloatArrayParam, i: number, xfunc: any, yfunc: any): Int8Array { // Oct-encode single normal vector in 2 bytes
    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
    if (array[i + 2] < 0) {
        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        x = tempx;
        y = tempy;
    }
    // @ts-ignore
    return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))]);
}


/**
 * Computes the dot product of a 3D vector from an array with another 3D vector.
 *
 * @param {FloatArrayParam} array - The array containing the first vector's components.
 * @param {number} i - The index of the first vector's X component in the array.
 * @param {FloatArrayParam} createVec3 - The second 3D vector as an array.
 * @returns {number} The dot product of the two vectors.
 */
function dot(array: FloatArrayParam, i: number, createVec3: FloatArrayParam): number {
    return array[i] * createVec3[0] + array[i + 1] * createVec3[1] + array[i + 2] * createVec3[2];
}

/**
 * Decompresses UV coordinates using a transformation matrix.
 *
 * This function applies a decompression matrix to a given UV coordinate,
 * adjusting it based on the transformation parameters.
 *
 * @param {FloatArrayParam} uv - The compressed UV coordinates as a 2-element array.
 * @param {FloatArrayParam} decompressMatrix - The 3x3 decompression matrix stored in a 1D array.
 * @param {FloatArrayParam} [dest] - Optional destination array for decompressed UVs. If not provided, a new Float32Array(2) is created.
 * @returns {FloatArrayParam} The decompressed UV coordinates.
 */
export function decompressUV(
    uv: FloatArrayParam,
    decompressMatrix: FloatArrayParam,
    dest: FloatArrayParam = new Float32Array(2)
): FloatArrayParam {
    if (uv.length < 2 || decompressMatrix.length < 8) {
        throw new Error("Invalid input arrays: UV must have at least 2 elements, and decompressMatrix must have at least 8 elements.");
    }

    const u = uv[0];
    const v = uv[1];

    dest[0] = u * decompressMatrix[0] + decompressMatrix[6];
    dest[1] = v * decompressMatrix[4] + decompressMatrix[7];

    return dest;
}


/**
 * Decompresses an array of UV coordinates using a transformation matrix.
 *
 * This function applies a decompression matrix to a batch of UV coordinates,
 * adjusting them based on the transformation parameters.
 *
 * @param {FloatArrayParam} uvs - The compressed UV coordinates (flat array).
 * @param {FloatArrayParam} decompressMatrix - The 3x3 decompression matrix stored in a 1D array.
 * @param {FloatArrayParam} [dest] - Optional destination array. If not provided, a new Float32Array is created.
 * @returns {FloatArrayParam} The decompressed UV coordinates.
 */
export function decompressUVs(
    uvs: FloatArrayParam,
    decompressMatrix: FloatArrayParam,
    dest: FloatArrayParam = new Float32Array(uvs.length)
): FloatArrayParam {
    if (uvs.length % 2 !== 0 || decompressMatrix.length < 8) {
        throw new Error("Invalid input: UVs must be a multiple of 2, and decompressMatrix must have at least 8 elements.");
    }

    for (let i = 0, len = uvs.length; i < len; i += 2) {
        dest[i] = uvs[i] * decompressMatrix[0] + decompressMatrix[6];
        dest[i + 1] = uvs[i + 1] * decompressMatrix[4] + decompressMatrix[7];
    }

    return dest;
}


/**
 * Decompresses a single oct-encoded normal vector into a 3D unit vector.
 *
 * @param {FloatArrayParam} oct - The compressed normal vector (2D).
 * @param {FloatArrayParam} result - The destination array to store the decompressed normal (3D).
 * @returns {FloatArrayParam} The decompressed 3D normal vector.
 */
export function decompressNormal(
    oct: FloatArrayParam,
    result: FloatArrayParam
): FloatArrayParam {
    if (oct.length < 2 || result.length < 3) {
        throw new Error("Invalid input: oct must have at least 2 elements, and result must have at least 3 elements.");
    }

    let x = (2 * oct[0] + 1) / 255;
    let y = (2 * oct[1] + 1) / 255;
    let z = 1 - Math.abs(x) - Math.abs(y);

    if (z < 0) {
        const tempx = (1 - Math.abs(y)) * Math.sign(x);
        const tempy = (1 - Math.abs(x)) * Math.sign(y);
        x = tempx;
        y = tempy;
    }

    const length = Math.sqrt(x * x + y * y + z * z);
    result[0] = x / length;
    result[1] = y / length;
    result[2] = z / length;

    return result;
}


/**
 * Decompresses an array of oct-encoded normal vectors into 3D unit vectors.
 *
 * @param {FloatArrayParam} octs - The compressed normal vectors (flat array).
 * @param {FloatArrayParam} result - The destination array to store the decompressed normals.
 * @returns {FloatArrayParam} The decompressed 3D normal vectors.
 */
export function decompressNormals(
    octs: FloatArrayParam,
    result: FloatArrayParam
): FloatArrayParam {
    if (octs.length % 2 !== 0) {
        throw new Error("Invalid input: octs must contain an even number of elements.");
    }
    if (result.length < (octs.length / 2) * 3) {
        throw new Error("Invalid output array: result must be large enough to store all decompressed normals.");
    }

    for (let i = 0, j = 0, len = octs.length; i < len; i += 2, j += 3) {
        let x = (2 * octs[i] + 1) / 255;
        let y = (2 * octs[i + 1] + 1) / 255;
        let z = 1 - Math.abs(x) - Math.abs(y);

        if (z < 0) {
            const tempx = (1 - Math.abs(y)) * Math.sign(x);
            const tempy = (1 - Math.abs(x)) * Math.sign(y);
            x = tempx;
            y = tempy;
        }

        const length = Math.sqrt(x * x + y * y + z * z);
        result[j] = x / length;
        result[j + 1] = y / length;
        result[j + 2] = z / length;
    }

    return result;
}


/**
 * Decodes a single oct-encoded 2D normal vector into a 3D unit vector.
 *
 * This function decodes a pair of oct-encoded normal components (x, y) from the input `oct` array,
 * and calculates the third component (z) to ensure the resulting 3D vector is a unit vector.
 * The z component is computed to make sure the vector lies on the unit sphere. The resulting vector
 * is then normalized to ensure its length is 1.
 *
 * The decoding process involves:
 * - Scaling and offsetting the oct values to [-1, 1] range.
 * - Computing the missing z component.
 * - Normalizing the resulting vector.
 *
 * @param {Int8Array} oct - An array containing the oct-encoded normal components (x, y).
 * @param {FloatArrayParam} result - A pre-allocated array where the decoded 3D unit vector will be stored (default is `createVec3()`).
 * @returns {FloatArrayParam} The input `result` array, populated with the decoded 3D unit vector.
 *
 * @example
 * const oct = new Int8Array([1, -1]);
 * const result = new Float32Array(3);
 * octDecodeVec2(oct, result);
 * console.log(result); // Decoded 3D unit vector
 */
function octDecodeVec2(oct: Int8Array<any>, result: FloatArrayParam = createVec3()): FloatArrayParam {
    let x = oct[0];
    let y = oct[1];

    // Scale and offset the oct values to the range [-1, 1]
    x = (2 * x + 1) / 255;
    y = (2 * y + 1) / 255;

    // Calculate the z component to ensure the normal lies on the unit sphere
    let z = 1 - Math.abs(x) - Math.abs(y);

    // If z is negative, adjust x and y to ensure correct direction
    if (z < 0) {
        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
    }

    // Normalize the vector (x, y, z) to have unit length
    const length = Math.sqrt(x * x + y * y + z * z);
    result[0] = x / length;
    result[1] = y / length;
    result[2] = z / length;

    return result;
}


/**
 * Decodes a sequence of oct-encoded 2D normal vectors into 3D unit vectors.
 *
 * This function takes pairs of oct-encoded normal components (x, y), which are stored as signed 8-bit integers,
 * and decodes them into 3D vectors by calculating the z component based on the x and y values. The resulting
 * 3D vectors are normalized and stored in the result array.
 *
 * The decoding process involves:
 * - Scaling and offsetting the oct values to [-1, 1] range.
 * - Computing the missing z component to ensure the decoded vectors lie on the unit sphere.
 * - Normalizing the resulting vectors to have unit length.
 *
 * @param {Int8Array} octs - An array of oct-encoded normal components, stored as pairs of signed 8-bit integers (x, y).
 * @param {FloatArrayParam} result - A pre-allocated array where the decoded 3D unit vectors will be stored.
 * @returns {FloatArrayParam} The input `result` array, populated with the decoded 3D normal vectors (x, y, z).
 *
 * @example
 * const octs = new Int8Array([1, -1, 1, 1, -1, -1]);
 * const result = new Float32Array(9); // 3 normal vectors
 * octDecodeVec2s(octs, result);
 * console.log(result); // Decoded 3D normals
 */
function octDecodeVec2s(octs: Int8Array<any>, result: FloatArrayParam): FloatArrayParam {
    const len = octs.length;
    let j = 0;

    // Iterate over the input array two bytes (x, y) at a time
    for (let i = 0; i < len; i += 2) {
        let x = octs[i];
        let y = octs[i + 1];

        // Scale the oct values to the range [-1, 1]
        x = (2 * x + 1) / 255;
        y = (2 * y + 1) / 255;

        // Compute the z component to ensure the normal lies on the unit sphere
        let z = 1 - Math.abs(x) - Math.abs(y);

        // If z is negative, adjust x and y to ensure the normal points in the correct direction
        if (z < 0) {
            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        }

        // Normalize the vector (x, y, z) to have unit length
        const length = Math.sqrt(x * x + y * y + z * z);
        result[j] = x / length;
        result[j + 1] = y / length;
        result[j + 2] = z / length;

        j += 3;
    }

    return result;
}


/**
 * Quantizes 3D position data into a compressed 16-bit format and generates a matrix for decompressing the positions.
 * The function maps the 3D positions into a defined axis-aligned bounding box (AABB), scales them to fit into
 * a 16-bit integer range, and then constructs a transformation matrix (combining translation and scaling) for
 * future decompression operations.
 *
 * This process is commonly used in mesh compression to minimize the storage size of the positions while
 * maintaining the relative precision within the bounding box. The decompress matrix can be used to recover
 * the original positions after decompression.
 *
 * @param {FloatArrayParam} positions - A flat array of 3D position data (x, y, z).
 * @param {FloatArrayParam} aabb - The axis-aligned bounding box (AABB) represented as a 6-element array [xmin, ymin, zmin, xmax, ymax, zmax].
 * @param {FloatArrayParam} positionsDecompressMatrix - A 4x4 matrix to be populated with the transformation matrix for decompression.
 * @returns {Uint16Array} A new array containing the quantized positions in a compressed 16-bit format.
 *
 * @example
 * const positions = new Float32Array([0.5, 0.7, 1.0, 1.2, 1.8, 2.0]);
 * const aabb = new Float32Array([0, 0, 0, 2, 2, 2]);
 * const positionsDecompressMatrix = new Float32Array(16); // 4x4 matrix
 * const quantizedPositions = quantizePositions3AndCreateMat4(positions, aabb, positionsDecompressMatrix);
 * console.log(quantizedPositions);
 * console.log(positionsDecompressMatrix); // The transformation matrix for decompression
 */
export function quantizePositions3AndCreateMat4(
    positions: FloatArrayParam,
    aabb: FloatArrayParam,
    positionsDecompressMatrix: FloatArrayParam
): Uint16Array<any> {

    const lenPositions = positions.length;
    const positionsCompressed = new Uint16Array(lenPositions);

    // Extract AABB coordinates for min and max boundaries
    const [xmin, ymin, zmin, xmax, ymax, zmax] = aabb;

    // Calculate the AABB dimensions for scaling
    const xwid = xmax - xmin;
    const ywid = ymax - ymin;
    const zwid = zmax - zmin;

    // Max range for 16-bit unsigned integers
    const maxInt = 65525;

    // Precompute multipliers to map positions into the 16-bit integer range
    const xMultiplier = maxInt / xwid;
    const yMultiplier = maxInt / ywid;
    const zMultiplier = maxInt / zwid;

    // Helper function to ensure no negative values during quantization
    const verify = (num: number): number => Math.max(0, num);

    // Quantize the positions (x, y, z)
    for (let i = 0; i < lenPositions; i += 3) {
        positionsCompressed[i] = Math.floor(verify(positions[i] - xmin) * xMultiplier);
        positionsCompressed[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);
        positionsCompressed[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);
    }

    // Create the decomposition matrix: translation + scaling
    const translate = new Float32Array(16);
    identityMat4(translate);
    translationMat4v(aabb, translate);

    const scale = new Float32Array(16);
    identityMat4(scale);
    scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);

    // Combine the translation and scaling into the decompress matrix
    mulMat4(translate, scale, positionsDecompressMatrix);

    return positionsCompressed;
}


/**
 * Quantizes the position values of 3D coordinates into a compressed 16-bit representation.
 * The positions are mapped into a defined bounding box (AABB) and then scaled to fit into
 * a 16-bit integer range, minimizing precision loss.
 *
 * This process is commonly used in mesh compression techniques to reduce the memory footprint of
 * position data while maintaining relative accuracy within the bounds of the specified AABB.
 *
 * @param {FloatArrayParam} positions - A flat array of 3D position data (x, y, z).
 * @param {FloatArrayParam} aabb - The axis-aligned bounding box (AABB) represented as a 6-element array [xmin, ymin, zmin, xmax, ymax, zmax].
 * @returns {Uint16Array} A new array containing the quantized positions in a compressed 16-bit format.
 *
 * @example
 * const positions = new Float32Array([0.5, 0.7, 1.0, 1.2, 1.8, 2.0]);
 * const aabb = new Float32Array([0, 0, 0, 2, 2, 2]);
 * const quantizedPositions = quantizePositions3(positions, aabb);
 * console.log(quantizedPositions);
 */
export function quantizePositions3(positions: FloatArrayParam, aabb: FloatArrayParam): Uint16Array<any> {
    const lenPositions = positions.length;
    const positionsCompressed = new Uint16Array(lenPositions);

    // Extract AABB coordinates for min and max boundaries
    const [xmin, ymin, zmin, xmax, ymax, zmax] = aabb;

    // Calculate dimensions of the AABB for scaling
    const xwid = xmax - xmin;
    const ywid = ymax - ymin;
    const zwid = zmax - zmin;

    // Max range of 16-bit unsigned integers
    const maxInt = 65525;

    // Precompute multipliers to map positions into 16-bit range
    const xMultiplier = maxInt / xwid;
    const yMultiplier = maxInt / ywid;
    const zMultiplier = maxInt / zwid;

    // Helper function to ensure no negative values in quantization process
    const verify = (num: number): number => Math.max(0, num);

    // Quantize each position (x, y, z)
    for (let i = 0; i < lenPositions; i += 3) {
        // Quantize each component (x, y, z)
        positionsCompressed[i] = Math.floor(verify(positions[i] - xmin) * xMultiplier);
        positionsCompressed[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);
        positionsCompressed[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);
    }

    return positionsCompressed;
}


/**
 * Transforms normals by applying a world normal matrix and then oct-encodes them to minimize rounding errors.
 *
 * This function takes an array of normals, transforms them using a world normal matrix, and then oct-encodes them
 * with optimizations to minimize rounding errors. The function tests different combinations of the `ceil` and `floor`
 * functions for the oct-encoding process and picks the encoding that maximizes the cosine similarity.
 *
 * @param {FloatArrayParam} worldNormalMatrix - A 4x4 matrix used to transform normals from local space to world space.
 * @param {FloatArrayParam} normals - A flat array of normals in local space (x, y, z components).
 * @param {number} lenNormals - The length of the `normals` array, indicating the number of normals to process.
 * @param {FloatArrayParam} compressedNormals - An array where the compressed normals will be stored.
 * @param {number} lenCompressedNormals - The length of the `compressedNormals` array before processing begins.
 * @returns {number} The updated length of the `compressedNormals` array.
 *
 * @example
 * const worldMatrix = new Float32Array([ ... 4x4 matrix ... ]);
 * const normals = new Float32Array([0.5, -0.5, 0.7, -0.3, 0.8, 0.5]);
 * const compressedNormals = new Float32Array(normals.length);
 * const newLen = transformAndOctEncodeNormals(worldMatrix, normals, normals.length, compressedNormals, 0);
 * console.log(newLen, compressedNormals);
 */
export function transformAndOctEncodeNormals(
    worldNormalMatrix: FloatArrayParam,
    normals: FloatArrayParam,
    lenNormals: number,
    compressedNormals: FloatArrayParam,
    lenCompressedNormals: number
): number {
    // Helper function for computing the dot product of two vectors
    const dot = (p: FloatArrayParam, createVec3: FloatArrayParam): number => {
        return p[0] * createVec3[0] + p[1] * createVec3[1] + p[2] * createVec3[2];
    };

    // Local and world normal buffers for transformation
    let localNormal = new Float32Array(3); // Local normal vector (x, y, z)
    let worldNormal = new Float32Array(3); // Transformed world normal vector (x, y, z)
    let best: Int8Array<any>, currentCos: number, bestCos: number, dec: FloatArrayParam;

    for (let i = 0; i < lenNormals; i += 3) {
        // Load normal from input array
        localNormal[0] = normals[i];
        localNormal[1] = normals[i + 1];
        localNormal[2] = normals[i + 2];

        // Transform normal into world space
        transformVec3(worldNormalMatrix, localNormal, worldNormal);
        normalizeVec3(worldNormal, worldNormal); // Normalize the transformed normal

        bestCos = -Infinity; // Start with a very low best cosine similarity

        // Test different combinations of ceil and floor for oct-encoding
        for (const xfunc of ['floor', 'ceil']) {
            for (const yfunc of ['floor', 'ceil']) {
                // Encode normal using oct-encoding
                const oct = octEncodeVec3(worldNormal, xfunc, yfunc);
                dec = octDecodeVec2(oct);

                // Calculate cosine similarity
                currentCos = dot(worldNormal, dec);

                // Keep the best encoding with the highest cosine similarity
                if (currentCos > bestCos) {
                    best = oct;
                    bestCos = currentCos;
                }
            }
        }

        // Store the best compressed normal (x, y), with z unused
        compressedNormals[lenCompressedNormals + i] = best[0];
        compressedNormals[lenCompressedNormals + i + 1] = best[1];
        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // z is unused
    }

    // Update and return the new length of the compressed normals array
    lenCompressedNormals += lenNormals;
    return lenCompressedNormals;
}


/**
 * Oct-encodes a 3D vector (x, y, z) into a 2-byte representation.
 *
 * This function normalizes a 3D vector to the 2D oct encoding range and encodes it
 * using the specified math functions (`xfunc` and `yfunc`), which typically are 'floor' or 'ceil'.
 *
 * @param {FloatArrayParam} p - A 3D vector, typically representing a normal (x, y, z).
 * @param {string} xfunc - The math function to apply to the x component ('floor', 'ceil', etc.).
 * @param {string} yfunc - The math function to apply to the y component ('floor', 'ceil', etc.).
 * @returns {Int8Array} The oct-encoded 2D vector as a 2-element Int8Array.
 *
 * @throws {Error} If xfunc or yfunc are not valid function names.
 *
 * @example
 * const vec3 = new Float32Array([0.5, -0.5, 0.5]);
 * const encoded = octEncodeVec3(vec3, 'floor', 'ceil');
 * console.log(encoded); // Int8Array with encoded vector values
 */
export function octEncodeVec3(
    p: FloatArrayParam,
    xfunc: string,
    yfunc: string
): Int8Array<any> {
    if (typeof Math[xfunc] !== 'function' || typeof Math[yfunc] !== 'function') {
        throw new Error(`Invalid math function names: ${xfunc} or ${yfunc} are not valid functions.`);
    }

    const total = Math.abs(p[0]) + Math.abs(p[1]) + Math.abs(p[2]);
    let x = p[0] / total;
    let y = p[1] / total;

    if (p[2] < 0) {
        // Adjust coordinates based on z sign
        x = (1 - Math.abs(y)) * Math.sign(x);
        y = (1 - Math.abs(x)) * Math.sign(y);
    }

    // Apply the math function (e.g., 'floor', 'ceil') and scale to 127.5
    const encodedX = Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0));
    const encodedY = Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0));

    return new Int8Array([encodedX, encodedY]);
}


/**
 * Oct-encodes a single normal vector (x, y) into a 2-byte representation.
 *
 * This function normalizes the 3D normal vector to the 2D oct encoding range and encodes it
 * using a specified math function (`xfunc` and `yfunc` are typically 'floor' or 'ceil').
 *
 * @param {FloatArrayParam} array - The array containing the 3D normal vector.
 * @param {number} i - The index of the normal vector's x component in the array.
 * @param {string} xfunc - The math function to apply to the x component ('floor', 'ceil', etc.).
 * @param {string} yfunc - The math function to apply to the y component ('floor', 'ceil', etc.).
 * @returns {Int8Array} The oct-encoded normal vector as a 2-element Int8Array.
 *
 * @throws {Error} If xfunc or yfunc are not valid function names.
 *
 * @example
 * const normal = new Float32Array([0.5, -0.5, 0.5]);
 * const encoded = octEncodeNormal(normal, 0, 'floor', 'ceil');
 * console.log(encoded); // Int8Array with encoded normal values
 */
export function octEncodeNormal(
    array: FloatArrayParam,
    i: number,
    xfunc: string,
    yfunc: string
): Int8Array<any> {
    if (typeof Math[xfunc] !== 'function' || typeof Math[yfunc] !== 'function') {
        throw new Error(`Invalid math function names: ${xfunc} or ${yfunc} are not valid functions.`);
    }

    const total = Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]);
    let x = array[i] / total;
    let y = array[i + 1] / total;

    if (array[i + 2] < 0) {
        // Adjust coordinates based on z sign
        const tempx = (1 - Math.abs(y)) * Math.sign(x);
        const tempy = (1 - Math.abs(x)) * Math.sign(y);
        x = tempx;
        y = tempy;
    }

    // Apply the math function (e.g., 'floor', 'ceil') and scale to 127.5
    const encodedX = Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0));
    const encodedY = Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0));

    return new Int8Array([encodedX, encodedY]);
}


/**
 * Compresses a flat array of floating-point RGB or RGBA colors into a Uint16Array.
 *
 * This function scales floating-point color values (0.0 to 1.0) to an 8-bit range (0-255),
 * storing them in a `Uint16Array` for reduced memory usage.
 *
 * @param {FloatArrayParam} colors - A flat array of floating-point color values (RGB or RGBA).
 *                                   Each color component should be in the range [0, 1].
 * @returns {Uint16Array} A compressed Uint16Array where each value represents a color channel (0-255).
 *
 * @throws {Error} If input contains values outside the expected [0,1] range.
 *
 * @example
 * const colors = new Float32Array([0.5, 0.2, 0.8, 1.0, 0.3, 0.6, 0.1, 1.0]);
 * const compressed = compressRGBColors(colors);
 * console.log(compressed); // Uint16Array([127, 51, 204, 255, 76, 153, 25, 255])
 */
export function compressRGBColors(colors: FloatArrayParam): Uint16Array<any> {
    const len = colors.length;
    const compressed = new Uint16Array(len);

    for (let i = 0; i < len; i++) {
        if (colors[i] < 0 || colors[i] > 1) {
            throw new Error(`Color value at index ${i} (${colors[i]}) is out of range [0, 1].`);
        }
        compressed[i] = Math.round(colors[i] * 255);
    }

    return compressed;
}


